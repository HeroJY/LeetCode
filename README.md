本项目为LeetCode算法刷题

##2019-03-26

*两数相加（addtwonumbers）

无思维难点

##2019-03-27

*两数相加进阶（addtwonumbersII）

思维难点

（1）如果转换为数字，会出现越界，因此否定

（2）使用栈的特性，先进后出，变成两数相加问题，问题解决

##2019-03-28

*无重复字符的最长子串

思维难点

（1）如何判断是否重复（这里借用了Java的API）

（2）时间复杂度过长，优化时需要考虑耗时最长部分逻辑

##2019-04-02

*最长回文子串

思维难点

（1）如何判断为回文子串（这里需要分成奇偶讨论，主要是因为奇偶的回文子串对称中心不一样）

##2019-04-04

*最短回文串

思维难点

（1）暴力破解，转换为寻找当前字符串最长从第一个字符开始的回文子串，然后将其余的不能组成回文子串的字符添加到前面

（2）需要注意时间复杂度和空间复杂度，同时需要注意，将偶数判断放在前面

##2019-04-11

*回文对

思维难点

（1）暴力破解首先遍历所有的数组；其次判断当前数组是否是自己，不是的话就拼接；最后判断拼接的字符串是否为回文串

（2）暴力破解时间复杂度过高，最终结果为：92 / 134 个通过测试用例

（3）网上提供一个思路，字典树的应用（这里需要去学习字典树）

##2019-04-15

*回文数

无思维难点

##2019-04-19

*回文链表

思维难点

（1）从链表中取出时分别入队列和栈，然后逐个比较。此方法时间复杂度和空间复杂度较高

（2）先找到中点，然后将后半段反转，再和前半段进行比较。此方法有两个关键

    （2-1）如何找到中点（利用快慢指针找到链表中位数，如果为偶数则找到下中位数）
    
    （2-2）如何将后半段反转（利用头插法反转链表这时候空间复杂度就不为O(1)，为O(n),所以需要就地反转)
    
*实现strStr()

思维难点

（1）如何记录开始位置（利用计数）

（2）如何确认匹配完成（当被匹配字符串剩余长度小于匹配字符串剩余长度时返回-1，或者当匹配字符串全匹配上）

（3）如何回溯匹配失败的位置（通过记录的位置+1来进行遍历）

（4）可以使用KMP算法提高速度

##2019-08-22

*全排列

思维难点

（1）如何记录已使用的状态

（2）在递归时需要回溯已使用的状态

##2019-08-29

*全排列，不重复

思维难点

（1）在基于回溯法时需要进行剪枝

（2）在递归时需要先将排列的对象进行排序，以便于剪枝

    
